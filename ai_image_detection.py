# -*- coding: utf-8 -*-
"""ai-image-detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19Pqof07dsMcIyiVRvdIxOrfpUPmQ0LMQ
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import seaborn as sns
# %matplotlib inline

np.random.seed(2)

from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
import itertools

from keras.utils.np_utils import to_categorical # convert to one-hot-encoding
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D
from keras.optimizers import RMSprop
from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import ReduceLROnPlateau, EarlyStopping

df= pd.read_csv('train.csv')
df.head()



x_train= df.drop('labels', axis=1).values

y_train= df['labels'].values

test= pd.read_csv('test.csv')
x_test= test.drop('id', axis=1).values

x_train = x_train.reshape(len(x_train), 20, 20, 3)
x_test = x_test.reshape(len(x_test), 20, 20, 3)
y_train = y_train.reshape(len(y_train), 1)
y_test = pd.read_csv('solution_format.csv')
y_test = y_test.drop('id', axis=1)
y_test = y_test.values.reshape(len(y_test), 1)

model = Sequential()

model.add(Conv2D(filters = 32, kernel_size = (3,3),padding = 'valid',
                 activation ='relu', input_shape = (20,20,3)))
print("Input: ", model.input_shape)
print("Output: ", model.output_shape)

model.add(Conv2D(filters = 32, kernel_size = (3,3),padding = 'valid',
                 activation ='relu'))
print("Input: ", model.input_shape)
print("Output: ", model.output_shape)

model.add(MaxPool2D(pool_size=(2,2)))

model.add(Dropout(0.25))
print("Input: ", model.input_shape)
print("Output: ", model.output_shape)

model.add(Flatten())
model.add(Dense(256, activation = "relu"))
model.add(Dropout(0.5))
model.add(Dense(2, activation = "sigmoid"))

optimizer = RMSprop(lr=0.0005, rho=0.9, epsilon=1e-08, decay=0.0)



model.compile(optimizer=optimizer,
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
model.fit(x_train, y_train, epochs=10)

model.save_weights('weights.h5')

x_test.shape

model.evaluate(x_test, y_test)

from sklearn.metrics import f1_score

x_test.shape

y_test.shape

y_pred= model.predict(x_test)
y_pred

type(y_pred)

y_classes = [np.argmax(element) for element in y_pred]
y_classes = np.array(y_classes)
y_classes

Y_test = np.array(y_test)
Y_test = Y_test.flatten()
Y_test

f1 = f1_score(Y_test, y_classes)
print("F1 score:", f1)

model = Sequential()

model.add(Conv2D(filters = 32, kernel_size = (3,3),padding = 'valid',
                 activation ='relu', input_shape = (20,20,3)))
print("Input: ", model.input_shape)
print("Output: ", model.output_shape)

model.add(Conv2D(filters = 32, kernel_size = (3,3),padding = 'valid',
                 activation ='relu'))
print("Input: ", model.input_shape)
print("Output: ", model.output_shape)

model.add(MaxPool2D(pool_size=(2,2)))

model.add(Dropout(0.25))
print("Input: ", model.input_shape)
print("Output: ", model.output_shape)

model.add(Flatten())
model.add(Dense(256, activation = "relu"))
model.add(Dropout(0.5))
model.add(Dense(2, activation = "sigmoid"))
model.load_weights('weights.h5')

